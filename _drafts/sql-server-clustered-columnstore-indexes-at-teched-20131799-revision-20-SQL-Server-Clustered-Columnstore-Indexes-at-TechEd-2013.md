---
id: 1820
title: SQL Server Clustered Columnstore Indexes at TechEd 2013
date: 2013-06-11T04:00:00+00:00
author: remus
layout: revision
guid: http://rusanu.com/2013/06/11/1799-revision-20/
permalink: /2013/06/11/1799-revision-20/
---
Now that the TechEd 2013 presentations are <a href="http://channel9.msdn.com/Events/TechEd/NorthAmerica/2013" target="_blank">up online on Channel9</a> you can checkout for yourself Brian Mitchell&#8217;s presentation <a href="http://channel9.msdn.com/Events/TechEd/NorthAmerica/2013/DBI-B322" target="_blank">What&#8217;s New for Columnstore Indexes and Batch Mode Processing</a>. Brian does a great job at presenting the the new updatable clustered columnstore indexes and the enhancements done to the vectorized query execution (aka. batch mode). Besides the TechEd presentation there is also another excellent resource available online right now for your education on the topic is the <a href="http://www.sigmod.org/2013/" target="_blank">SIGMOD 2013</a> paper <a href="http://research.microsoft.com/pubs/193599/Apollo3%20-%20Sigmod%202013%20-%20final.pdf" target="_blank">Enhancements to SQL Server Column Stores</a>. This paper cites several of the improvements that are available in clustered columnstores, besides the obvious updatability: 

  * Improved Index Build
  * Sampling Support
  * Bookmark Support
  * Schema modification support
  * Support for short strings
  * Mixed Execution Mode
  * Hash Join support
  * Improvements in Bitmap filters
  * Archival support

It should be no surprise to anyone studying columnar storage that the updatable clustered columnstores coming with the next version of SQL Server are based on deltastores. I talked before about the [SQL Server 2012 Columnstore internals](http://rusanu.com/2012/05/29/inside-the-sql-server-2012-columnstore-indexes/) and I explained why the highly compressed format that makes columnar storage so fast is also make it basically impossible to update in-place. The technique of having a &#8216;deltastore&#8217; which stores updates and merge it just-in-time with the columnar data during scans is not new and is employed by several of the columnar storage solution vendors.

<!-- more -->

# Deltastores

<p class="callout float-right">
  Deltastores are ordinary B-Trees that store uncompressed row groups of the clustered columnstore
</p>

Columnstores introduce a new unit of organization, a row-group. A row-group is a logical unit that groups up to 2<sup>20</sup> rows (about 1 million rows). In SQL Server 2012 the row-groups where implicit and there was catalog view to show them. As you can see in Brian&#8217;s presentation SQL Server 14 adds a new catalog view: <tt>sys.column_store_row_groups</tt>. This catalog view show the state of each row group for all columnstores (including non-clustered ones). Updatable clustered columnstores can show the row groups in COMPRESSED state or in OPEN/CLOSED state. The OPEN/CLOSED row groups are deltastores (yes, there could be multiple deltastores per columnstore, see the above mentioned SIGMOD 2013 paper). OPEN row groups are ready to accept more inserts while CLOSED row groups have filled up and are awaiting compression. The structure of a deltastore is explained in the SIGMOD paper:

> A delta store contains the same columns as the corresponding column store index. The B-tree key is a unique integer row ID generated by the system (column stores do not have unique keys).

If you wonder what a _unique integer row ID generated by the system_ actually is, think how non-columnstore clustered non-unique keys use an uniqueifier column. Deltastores are managed entirely by the engine, there is no DDL to control the creation and deletion of deltastores. The engine creates a new deltastore whenever it needs one to handle inserts, closes them when full (have 1 million rows) and a background process called the Tuple Mover compresses this closed deltastores into columnar storage format.

# Tuple Mover

The background Tuple Mover process is responsible to compressing full deltastores. The Tuple Mover is an online operation, it does not prevent data reads from the deltastores being compressed. This is described in the SIGMOD paper:

> The Tuple Mover reads one closed delta store at a time and starts building the corresponding compressed segments. During this time scans continue to see and read the delta store. When the Tuple Mover has finished compressing the delta store, the newly created segments are made visible and the delta store is made invisible in a single, atomic operation. New scans will see and scan the compressed format. The Tuple Mover then waits for all scans still operating in the delta store to drain after which the delta store is removed.

Concurrent deletes or updates **are blocked** while the Tuple Mover compresses a deltastore. Concurrent Inserts are not blocked by the Tuple Mover. As you&#8217;ll learn more about updatable clustered columnstores you will hear more of this mantra: they target data warehousing scenarios and are optimized for reads and inserts. Updates and deletes should be **extremely** rare exceptions. As for the &#8216;background process&#8217; part of the Tuple Mover the closes analogy is the <a href="http://www.sqlskills.com/blogs/paul/inside-the-storage-engine-ghost-cleanup-in-depth/" target="_blank">Ghost Cleanup process</a>. Veterans know that Ghost Cleanup is never tuned right for _my_ job, is always either too aggressive for some users or too slow for others. Will Tuple Mover suffer from the same problems? I don&#8217;t expect it to, primarily because the unit of work is big. It takes time to accumulate 1 million rows in single row by row inserts.