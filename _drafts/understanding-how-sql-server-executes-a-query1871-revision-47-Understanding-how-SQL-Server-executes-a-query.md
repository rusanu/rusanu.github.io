---
id: 1918
title: Understanding how SQL Server executes a query
date: 2013-06-17T03:16:57+00:00
author: remus
layout: revision
guid: http://rusanu.com/2013/06/17/1871-revision-47/
permalink: /2013/06/17/1871-revision-47/
---
This article is an introduction into how SQL Server works. My target audience are the developers and I hope this article will help you write better database code and will help you get starting when having to investigate performance problems in the database back end.

## Requests

SQL Server is a client-server platform. The only way to interact with the back-end database is by sending requests that contain commands for the database. The protocol used to communicate between your application and the database is called TDS (Tabular Data Sream) and is described on MSDN in the Technical Document <a href="http://msdn.microsoft.com/en-us/library/dd304523.aspx" target="_blank">[MS-TDS]: Tabular Data Stream Protocol</a>. thr application can use one of the several client-side implementations of the protocol: the CLR managed SqlClient, OleDB, ODBC, JDBC, PHP Driver for SQL Server or the open source FreeTDS implementation. The gist of it is that when your application whats the database to do _anything_ it will send a request over the TDS protocol. The request itself can take several forms:

<!-- more -->

<a href="http://msdn.microsoft.com/en-us/library/dd357447.aspx" target="_blank">Batch Request</a> 
:   This request type contains just T-SQL text for a batch to be executed. This type of requests do not have parameters, but obviously the T-SQL batch itself wi can contain local variables declarations. This is the type of request SqlClient sends if you invoke any of the <a href="http://msdn.microsoft.com/en-us/library/hhxxcw8c.aspx" target="_blank"><tt>SqlCommand.ExecuteReader()</tt></a>/.<a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlcommand.executenonquery.aspx" target="_blank"><tt>ExecuteNonQuery()</tt></a>/.<a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlcommand.executescalar.aspx" target="_blank"><tt>ExecuteScalar()</tt></a>/.<a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlcommand.executexmlreader.aspx" target="_blank"><tt>ExecuteXmlReader()</tt></a> (or they respective asyncronous equivalents) on a SqlCommand object with an empty <a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlcommand.parameters.aspx" target="_blank"><tt>Parameters</tt></a> list. If you monitor with SQL Profiler you will see an <a href="http://msdn.microsoft.com/en-us/library/ms190441.aspx" target="_blank">SQL:BatchStarting Event Class</a></dt> 
    
    <a href="http://msdn.microsoft.com/en-us/library/dd303353.aspx" target="_blank">Remote Procedure Call Request</a> 
    
    :   This request type contains a <a href="http://msdn.microsoft.com/en-us/library/dd357576.aspx" target="_blank">procedure identifier</a> to execute, along with any number of parameters. Of special interest is when the procedure id will be 12, ie. <a href="http://msdn.microsoft.com/en-us/library/ff848746.aspx" target="_blank"><tt>sp_execute</tt></a>. In this case the first parameter is the T-SQL text to execute, and this is the request that what your application will send if you execute a SqlCommand object with a non-empty <tt>Parameters</tt> list. If you monitor using SQL Profiler you will see an <a href="http://msdn.microsoft.com/en-us/library/dd357576.aspx" target="_blank">RPC:Starting Event Class</a>.
    
    <a href="http://msdn.microsoft.com/en-us/library/dd357606.aspx" target="_blank">Bulk Load Request</a> 
    
    :   Bulk Load is a special type request used by bulk insert operations, like the <a href="http://msdn.microsoft.com/en-us/library/ms162802.aspx" target="_blank">bcp.exe utility</a>, the <a href="http://msdn.microsoft.com/en-us/library/ms131708.aspx" target="_blank"><tt>IRowsetFastLoad</tt></a> OleDB interface or by the <a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlbulkcopy.aspx" target="_blank"><tt>SqlBulkcopy</tt></a> managed class. Bulk Load is different from the other requests because is the only request that starts execution before the request is complete on the TDS protocol. this allows it to start executing and then start consuming the <a href="http://msdn.microsoft.com/en-us/library/dd358082.aspx" target="_blank">stream</a> of data to insert.
    After a complete TDS request reaches the database engine SQL Server will create a task to handle the request. The list of requests in the server can be queried from <a href="http://msdn.microsoft.com/en-us/library/ms177648.aspx" target="_blank"><tt>sys.dm_exec_requests</tt></a>.
    
    ## Tasks
    
    The task will represent the request from beginning till completion. For example if the request is a SQL Batch type request the task will represent the entire batch, not individual statements. Individual statements inside the SQL Batch will not create new tasks. Certain individual statements inside the batch may execute with parallelism (often referred to as DOP, Degree Of Parallelism) and in their case the task will spawn new sub-tasks for executing in parallel. If the request returns a result the batch is complete when the result is completely consumed by the client (eg. when you dispose the <a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqldatareader.aspx" target="_blank"><tt>SqlDataReader</tt></a>). You can see the list of tasks in the server by querying <a href="http://msdn.microsoft.com/en-us/library/ms174963.aspx" target="_blank"><tt>sys.dm_os_tasks</tt></a>.
    
    When a new request reaches the server and the task is created to handle that request the task will be first PENDING, meaning the task did not yet start to execute. At this stage the server has no idea yet what the request actually is. The task has to start executing first, and for this the engine must assign a worker to it.
    
    ## Workers
    
    Workers are the thread pool of SQL Server. A number of workers is created initially at server start up and more can be created on-demand up to the configured <a href="http://msdn.microsoft.com/en-us/library/ms187024(v=sql.105).aspx" target="_blank"><tt>max worker threads</tt></a>. Only workers execute code. Workers are waiting for PENDING tasks to become available (from requests coming into the server) and then each worker takes exactly one task and executes it. The worker is busy (occupied) until the task finishes completely. Tasks that are PENDING when there are no more available workers will have to wait until one of the executing (running) task completes and the worker that executed that task becomes available to execute another pending task. For a SQL batch request the worker that picks up that task will execute the entire SQL batch (every statement). This should settle the often asked question whether statements in a SQL batch (=> request => task => worker) can execute in parallel: no, as they are executed on a single thread (=> worker) then each statement must complete before the next one starts. For statements that internally use parallelism (DOP > 1) and create sub-tasks, each sub-task goes through exactly the same cycle: it is created as PENDING and a worker must pick it up and execute it (a different worker from the SQL batch worker, that is by definition occupied!). The lists and state of workers inside SQL Server can be seen by querying <a href="http://msdn.microsoft.com/en-us/library/ms178626.aspx" target="_blank"><tt>sys.dm_os_workers</tt></a>.
    
    ## Parsing and Compilation
    
    Once a task started executing a request the first think it needs to do is to understand the content of the request. At this stage SQL Server will behave much like an interpreted language VM: the T-SQL text inside the request will be parsed and an <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">abstract syntax tree</a> will be created to represent the request. The entire request (batch) is parsed and compiled. If an error occurs at this stage, the requests terminates with a compilation error (the request is then complete, the task is done and the worker is free to pick up another pending task). SQL, and T-SQL, is a high end declarative language with extremely complex statements (think SELECT with several JOINs). Compilation of t-SQL batches does not result in executable code similar to native CPU instructions and not even similar to <a href="http://en.wikipedia.org/wiki/Common_Intermediate_Language" target="_blank">CLI instructions</a> or <a href="http://en.wikipedia.org/wiki/Java_bytecode" target="_blank">JVM bytecode</a>, but instead results primarily in <a href="http://en.wikipedia.org/wiki/Query_plan" target="_blank">data access plans</a> (or query plans). These plans describe the way to open the tables and indexes, search and locate the rows of interest, and do any data manipulation as requested in the SQL batch. For instance a query plan will contain describe an access path like <tt>'open index idx1 on table t, locate the row with the key 'k' and return the columns a and b'</tt>. As a side note: a common mistake done by developers is trying to come up with a single T-SQL query that cover many alternatives, usually by using clever expressions in the WHERE clause, often having many OR alternatives (eg. <tt>(COLUMN = @parameter OR @parameter IS NULL</tt>). For developers trying to keep things <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself" target="_blank">DRY</a> and avoiding repetition are good practices, for SQL queries they are plain bad. The compilation has to come up with an access path that work for _any_ value of the input parameters and the result is most often sub-optimal.
    
    ## Optimization
    
    Speaking of choosing an optimal data access path, this is the next stage in the lifetime of the request: optimization. In SQL, and in T-SQL, optimization means choosing the best the data access path from all the possible alternatives. Consider that if you have a simple query with join between two tables and each table has an additional index there are already 4 possible ways to access the data and the number of possibilities grows exponentially as the query complexity increases _and_ more alternative access paths are available (basically, more indexes). Add to this that the JOIN can be done using various strategies (nested loop, hash, merge) and you&#8217;ll see why optimization is such an important concept in SQL. SQL Server uses a cost based optimizer, meaning that it will consider all (or at least many) of the possible alternatives, try to make an educated guess about the cost of each alternative, and then choose the one with the lowest cost. Cost is calculated primarily by considering the size of data that would have to be read by each alternative. In order to come up with these costs SQL Server needs to know the size of each table and the distribution of column values, which is are available from the statistics associated with the data. Other factors considered are the CPU consumption and the memory required for each plan alternative. Using formulas tuned over many years of experience all these factors are synthesized into a single cost value for each alternative and then the alternative with the lowest cost is chosen as the query plan to be used.
    
    Exploring all these alternatives can be time consuming and this is why once a query plan is created is also cached for future reuse. Future similar requests can skip the optimization phase if they can find an already compiled and optimized query plan in the SQL Server internal cache. For a lengthier discussion see <a href="http://msdn.microsoft.com/en-us/library/ms181055.aspx" target="_blank">Execution Plan Caching and Reuse</a>.
    
    ## Execution
    
    Once a query plan is chosen by the Optimizer the request can start executing. The query plan gets translated into an actual execution tree. Each node in this tree is an operator. All operators implement an abstract interface with 3 methods: <tt>open()</tt>, <tt>next()</tt>, <tt>close()</tt>. The execution loop consists in calling <tt>open()</tt> on the operator that is at the root of the tree, then calling <tt>next()</tt> repeatedly until it returns false, and finally calling <tt>close()</tt>. The operator at the root of the tree will in turn call the same operation on each of its children operators, and these in turn call the same operations on their child operators and so on. At the leaf the trees there are usually physical access operators that actually retrieve data from tables and indexes. At intermediate levels there are operators that implement various data operations like filtering data, performing JOINs or sorting the rows. Queries that use parallelism use a special operator called an Exchange operator. The Exchange operator launches multiple threads (tasks => workers) into execution and asks each thread to execute a sub-tree of the query plan. It then aggregates the output from these operators, using a typical <a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem" target="_blank">multiple-producers-one-consumer</a> pattern. An excellent description of this execution model can be found in the <a href="http://paperhub.s3.amazonaws.com/dace52a42c07f7f8348b08dc2b186061.pdf" target="_blank">Volcano-An Extensible and Parallel Query Evaluation System</a>.
    
    This execution model applies not only to queries, but also to data modification (insert, delete, update). There are operators that handle inserting a row, operators that handle deleting a row and operators that handle updating a row. Some requests create trivial plans (eg. a <tt>INSERT INTO ... VALUES ...</tt>) while other creates extremely complex plans, but the execution is identical for all of the and occurs just as I described: the execution tree is iterated calling <tt>next()</tt> until its done.
    
    Some operators are very simple, consider for example the TOP(N) operator: when <tt>next()</tt> is called on it, all it just has to call <tt>next()</tt> on its children and keep a count. After N times being called, it simply return false w/o calling the children anymore, thus terminating the iteration of that particular sub-tree.
    
    Other operators have more complex behavior, consider what a nested loop operator has to do: it needs to keep track of the loop iteration position on both the outer child and inner child, call <tt>next()</tt> on the outer child, rewind the inner child and call <tt>next()</tt> on the inner child until the join predicate is satisfied (see <a href="http://blogs.msdn.com/b/craigfr/archive/2006/07/26/679319.aspx" target="_blank">Nested Loop Joins</a> for a more thorough discussion).
    
    Certain operators have a stop-and-go behavior, meaning that they cannot produce any output until they consumed all the input from their own children operators. Examples of such operators is SORT: the very first call to <tt>next()</tt> does not return until all the rows created by the children operators are retrieved and sorted. 
    
    An operator like HASH JOIN will be both complex and stop-and-go behavior: to build the hash table it has to call <tt>next()</tt> on the build side child until that operator returns false. It then calls <tt>next()</tt> on the probe side child operator until a match is found in the hash table, then return. Subsequent calls continue to call <tt>next()</tt> on the probe side child operator and return on hash table match, until the probe side child operator <tt>next()</tt> returns false (see <a href="http://blogs.msdn.com/b/craigfr/archive/2006/08/10/687630.aspx" target="_blank">Hash Join</a> for a more thorough discussion).
    
    ## Data Organization
    
    At this moment I feel is necessary to introduce the way data is organized in SQL Server, because understanding of the Data Access topic depends on understanding the data organization. Data in SQL Server can be organized one of three ways:
    
    Heaps
    :   A heap is the table w/o any order defined on it. The heap contains all the columns of a table. If a table is organized as a heap then whenever you are talking about the &#8216;table&#8217; then heap **is** the &#8216;table&#8217;. If you did not declare a <tt>PRIMARY KEY</tt> clause when you created the table then the table is a heap. A table created by a <tt>SELECT... INTO ... FROM ...</tt> statement will be a heap. For more details on how heaps are organized see <a href="http://msdn.microsoft.com/en-us/library/ms188270(v=sql.105).aspx" target="_blank">Heap Structures</a>.
    
    Clustered Indexes
    :   A clustered index is a table with an order defined on it. The clustered index contains all the columns of a table and if a table is organized as a clustered index then whenever you are talking about the &#8216;table&#8217; the clustered index **is** the &#8216;table&#8217;. Clustered indexes are <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank">B-Trees</a>. If you declare a primary key declared on a table then the same key is also used for the clustered index, unless the primary key is explicitly declared as NONCLUSTERED. For more details on how clustered index are organized see <a href="http://msdn.microsoft.com/en-us/library/ms177443(v=sql.105).aspx" target="_blank">Clustered Index Structure</a>.
    
    Nonclustered Indexes
    :   A nonclustered index is a copy of a subset of a table data with a specific order defined on it. A nonclustered index contains one ore more columns from the table. When talking about &#8220;indexes&#8221; on a table, most often the discussion refers to nonclustered indexes. Nonclustered indexes are <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank">B-Trees</a>. For more details on how nonclustered indexes are organized see <a href="http://msdn.microsoft.com/en-us/library/ms177484(v=sql.105).aspx" target="_blank">Nonclustred Index Structures</a>.
    
    With SQL Server 2012 there is another mode of organizing a data, namely <a href="http://rusanu.com/2012/05/29/inside-the-sql-server-2012-columnstore-indexes/" target="_blank">Nonclustered Columnstores</a> and in the next version of SQL Server there will also be a <a href="http://rusanu.com/2013/06/11/sql-server-clustered-columnstore-indexes-at-teched-2013/" target="_blank">Clustered Columnstore</a> mode. If you&#8217;re interested in them read the articles linked.
    
    ## Data Access
    
    At the leaf extremities of the execution tree there are operators that implement the access to the data. The operators will return an actual row of data from a table (or from an index) when the <tt>next()</tt> method is called on them. There are three possible data access operators:
    
    Scan Operator
    :   The Scan operator will iterate through all the rows in its source. A scan can never locate a particular row, it always has to scan the entire data set (hence it&#8217;s name&#8230;). If you inspect an execution plan you&#8217;ll possibly see any of the operators for <a href="http://msdn.microsoft.com/en-us/library/ms175184(v=sql.105).aspx" target="_blank"><tt>Clustered Index Scan</tt></a>, <a href="http://msdn.microsoft.com/en-us/library/ms178038(v=sql.105).aspx" target="_blank"><tt>Nonclustered Index Scan</tt></a>, <a href="http://msdn.microsoft.com/en-us/library/ms181129(v=sql.105).aspx" target="_blank"><tt>Table Scan</tt></a>, <a href="http://msdn.microsoft.com/en-us/library/cc280566(v=sql.105).aspx" target="_blank"><tt>Remote Index Scan</tt></a> and <a href="http://msdn.microsoft.com/en-us/library/ms178103(v=sql.105).aspx" target="_blank"><tt>Remote Scan</tt></a>. They are distinct operators because they apply to different data sources (indexes, tables, remote linked servers) but they all have in common the end-to-end scan behavior. As these operators have to read the entire data, always, they are always expensive. Only data warehousing queries should resort to these type of scans.
    
    Seek Operator
    :   The seek operator can locate a row directly based on a key. Seek can only operate on B-Tree organized data sources, so it can only be applied to Clustered and Nonclustered indexes. If an index has a complex key (multiple columns) then the Seek operator can only operate if values for the leftmost keys in the index definition are provided. To give an example, if an index has the key columns <tt>(A, B, C)</tt> then the Seek can locate the first row where <tt>A='a'</tt>, or the first row where <tt>A='a' AND B='b'</tt> or the first row where <tt>A='a' AND B='b' AND C='c'</tt>. However, on such an index, Seek cannot locate a row where <tt>B='b'</tt> or a row where <tt>C='c'</tt>. Seek operator is also capable of implementing ranges. Given the same index definition on <tt>(A, B, C)</tt> a Seek operator can iterate all rows where <tt>A > 'a' AND A < 'z'</tt> or all rows where <tt>A = 'a' AND B > 'b' AND B < 'z'</tt>, but it cannot iterate rows where <tt>B > 'b' AND B < 'z'</dd> 
        
        <p>
          . If you inspect an execution plan you will possibly see any of the operators <a href="http://msdn.microsoft.com/en-us/library/ms190400(v=sql.105).aspx" target="_blank">Clustered Index Seek</a>, <a href="http://msdn.microsoft.com/en-us/library/ms190376(v=sql.105).aspx" target="_blank"></a> or <a href="http://msdn.microsoft.com/en-us/library/cc280498(v=sql.105).aspx" target="_blank">Remote Index Seek</a>. They are distinct operators because they apply to different data sources, but they all have in common the capability to efficiently locate locate a row base dona key value or to iterate efficiently over a range of key values. Obviously there are no heap seek operators, as heaps, being unordered, do not have the capability to locate a row efficiently based on a key. Seek should be be the preferred data access method in almost every situation.</dd> 
          
          <dt>
            Bookmark Lookup Operator
          </dt>
          
          <dd>
            Bookmark lookup is a special data access operator that can efficiently locate a row based on a special type of value, called a bookmark. You cannot provide boomarks, only the engine internally can retrieve bookmarks for later lookup. And this is the gist of this special operator: it is never the primary data access operator, it will always be an operator used to look up a row that was previously accessed one of the other operators, a Scan or a Seek. Bookmarks can be looked up on any data organization mode, both on heaps and or B-Trees. In an execution plan you may see an <a href="http://msdn.microsoft.com/en-us/library/ms180920(v=sql.105).aspx" target="_blank">Bookmark Lookup</a>, a <a href="http://msdn.microsoft.com/en-us/library/ms190696(v=sql.105).aspx" target="_blank">Row ID Lookup</a> (Heap specific look up) or a <a href="http://msdn.microsoft.com/en-us/library/bb326635(v=sql.105).aspx" target="_blank">Key Value Lookup</a> (B-Tree specific look up).
          </dd>
          
          <p>
            Strictly speaking all the operators used to insert, delete or update rows are also data access operators. The <a href="http://msdn.microsoft.com/en-us/library/ms189101(v=sql.105).aspx" target="_blank">Inserted Scan</a> and the <a href="http://msdn.microsoft.com/en-us/library/ms188244(v=sql.105).aspx" target="_blank">Deleted Scan</a> operators do access data to iterate over the trigger <b>inserted</b> and <b>deleted</b> <a href="http://msdn.microsoft.com/en-us/library/ms191300(v=sql.105).aspx" target="_blank">pseudo-tables</a>. <a href="http://msdn.microsoft.com/en-us/library/ms187600(v=sql.105).aspx" target="_blank">Log Row Scan</a> is a more esoteric data access operator (it reads rows from the log, not from the data tables). But going into this level of detail to explain how these work would derail the purpose of this very article.
          </p>
          
          <p class="callout float-right">
            Data Access Redux: Scans read all the data. Seek read only the minimum required data. Heaps only support scans. B-Trees only support seeks if the leftmost index key(s) are specified.
          </p>