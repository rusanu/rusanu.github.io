---
id: 1893
title: Understanding how SQL Server executes a query
date: 2013-06-14T06:54:50+00:00
author: remus
layout: revision
guid: http://rusanu.com/2013/06/14/1871-revision-22/
permalink: /2013/06/14/1871-revision-22/
---
This article is an introduction into how SQL Server works. My target audience are the developers and I hope this article will help you write better database code and will help you get starting when having to investigate performance problems in the database back end.

## Requests

SQL Server is a client-server platform. The only way to interact with the back-end database is by sending requests that contain commands for the database. The protocol used to communicate between your application and the database is called TDS (Tabular Data Sream) and is described on MSDN in the Technical Document <a href="http://msdn.microsoft.com/en-us/library/dd304523.aspx" target="_blank">[MS-TDS]: Tabular Data Stream Protocol</a>. thr application can use one of the several client-side implementations of the protocol: the CLR managed SqlClient, OleDB, ODBC, JDBC, PHP Driver for SQL Server or the open source FreeTDS implementation. The gist of it is that when your application whats the database to do _anything_ it will send a request over the TDS protocol. The request itself can take several forms:

<!-- more -->

<a href="http://msdn.microsoft.com/en-us/library/dd357447.aspx" target="_blank">Batch Request</a> 
:   This request type contains just T-SQL text for a batch to be executed. This type of requests do not have parameters, but obviously the T-SQL batch itself wi can contain local variables declarations. This is the type of request SqlClient sends if you invoke any of the <a href="http://msdn.microsoft.com/en-us/library/hhxxcw8c.aspx" target="_blank"><tt>SqlCommand.ExecuteReader()</tt></a>/.<a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlcommand.executenonquery.aspx" target="_blank"><tt>ExecuteNonQuery()</tt></a>/.<a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlcommand.executescalar.aspx" target="_blank"><tt>ExecuteScalar()</tt></a>/.<a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlcommand.executexmlreader.aspx" target="_blank"><tt>ExecuteXmlReader()</tt></a> (or they respective asyncronous equivalents) on a SqlCommand object with an empty <a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlcommand.parameters.aspx" target="_blank"><tt>Parameters</tt></a> list. If you monitor with SQL Profiler you will see an <a href="http://msdn.microsoft.com/en-us/library/ms190441.aspx" target="_blank">SQL:BatchStarting Event Class</a></dt> 
    
    <a href="http://msdn.microsoft.com/en-us/library/dd303353.aspx" target="_blank">Remote Procedure Call Request</a> 
    
    :   This request type contains a <a href="http://msdn.microsoft.com/en-us/library/dd357576.aspx" target="_blank">procedure identifier</a> to execute, along with any number of parameters. Of special interest is when the procedure id will be 12, ie. <a href="http://msdn.microsoft.com/en-us/library/ff848746.aspx" target="_blank"><tt>sp_execute</tt></a>. In this case the first parameter is the T-SQL text to execute, and this is the request that what your application will send if you execute a SqlCommand object with a non-empty <tt>Parameters</tt> list. If you monitor using SQL Profiler you will see an <a href="http://msdn.microsoft.com/en-us/library/dd357576.aspx" target="_blank">RPC:Starting Event Class</a>.
    
    <a href="http://msdn.microsoft.com/en-us/library/dd357606.aspx" target="_blank">Bulk Load Request</a> 
    
    :   Bulk Load is a special type request used by bulk insert operations, like the <a href="http://msdn.microsoft.com/en-us/library/ms162802.aspx" target="_blank">bcp.exe utility</a>, the <a href="http://msdn.microsoft.com/en-us/library/ms131708.aspx" target="_blank"><tt>IRowsetFastLoad</tt></a> OleDB interface or by the <a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlbulkcopy.aspx" target="_blank"><tt>SqlBulkcopy</tt></a> managed class. Bulk Load is different from the other requests because is the only request that starts execution before the request is complete on the TDS protocol. this allows it to start executing and then start consuming the <a href="http://msdn.microsoft.com/en-us/library/dd358082.aspx" target="_blank">stream</a> of data to insert.
    After a complete TDS request reaches the database engine SQL Server will create a task to handle the request.
    
    ## Tasks
    
    The task will represent the request from beginning till completion. For example if the request is a SQL Batch type request the task will represent the entire batch, not individual statements. Individual statements inside the SQL Batch will not create new tasks. Certain individual statements inside the batch may execute with parallelism (often referred to as DOP, Degree Of Parallelism) and in their case the task will spawn new sub-tasks for executing in parallel. If the request returns a result the batch is complete when the result is completely consumed by the client (eg. when you dispose the <a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqldatareader.aspx" target="_blank"><tt>SqlDataReader</tt></a>). You can see the list of tasks in the server by querying <a href="http://msdn.microsoft.com/en-us/library/ms174963.aspx" target="_blank"><tt>sys.dm_os_tasks</tt></a>.
    
    When a new request reaches the server and the task is created to handle that request the task will be first PENDING, meaning the task did not yet start to execute. At this stage the server has no idea yet what the request actually is. The task has to start executing first, and for this the engine must assign a worker to it.
    
    ## Workers
    
    Workers are the thread pool of SQL Server. A number of workers is created initially at server start up and more can be created on-demand up to the configured <a href="http://msdn.microsoft.com/en-us/library/ms187024(v=sql.105).aspx" target="_blank"><tt>max worker threads</tt></a>. Only workers execute code. Workers are waiting for PENDING tasks to become available (from requests coming into the server) and then each worker takes exactly one task and executes it. The worker is busy (occupied) until the task finishes completely. Tasks that are PENDING when there are no more available workers will have to wait until one of the executing (running) task completes and the worker that executed that task becomes available to execute another pending task. For a SQL batch request the worker that picks up that task will execute the entire SQL batch (every statement). This should settle the often asked question whether statements in a SQL batch (=> request => task => worker) can execute in parallel: no, as they are executed on a single thread (=> worker) then each statement must complete before the next one starts. For statements that internally use parallelism (DOP > 1) and create sub-tasks, each sub-task goes through exactly the same cycle: it is created as PENDING and a worker must pick it up and execute it (a different worker from the SQL batch worker, that is by definition occupied!). The lists and state of workers inside SQL Server can be seen by querying <a href="http://msdn.microsoft.com/en-us/library/ms178626.aspx" target="_blank"><tt>sys.dm_os_workers</tt></a>.
    
    ## Parsing and Compilation
    
    Once a task started executing a request the first think it needs to do is to understand the content of the request. At this stage SQL Server will behave much like an interpreted language VM: the T-SQL text inside the request will be parsed and an <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">abstract syntax tree</a> will be created to represent the request. The entire request (batch) is parsed and compiled. If an error occurs at this stage, the requests terminates with a compilation error (the request is then complete, the task is done and the worker is free to pick up another pending task). SQL, and T-SQL, is a high end declarative language with extremely complex statements (think SELECT with several JOINs). Compilation of t-SQL batches does not result in executable code similar to native CPU instructions and not even similar to <a href="http://en.wikipedia.org/wiki/Common_Intermediate_Language" target="_blank">CLI instructions</a> or <a href="http://en.wikipedia.org/wiki/Java_bytecode" target="_blank">JVM bytecode</a>, but instead results primarily in <a href="http://en.wikipedia.org/wiki/Query_plan" target="_blank">data access plans</a> (or query plans). These plans describe the way to open the tables and indexes, search and locate the rows of interest, and do any data manipulation as requested in the SQL batch. For instance a query plan will contain describe an access path like <tt>'open index idx1 on table t, locate the row with the key 'k' and return the columns a and b'</tt>. As a side note: a common mistake done by developers is trying to come up with a single T-SQL query that cover many alternatives, usually by using clever expressions in the WHERE clause, often having many OR alternatives (eg. <tt>(COLUMN = @parameter OR @parameter IS NULL</tt>). For developers trying to keep things <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself" target="_blank">DRY</a> and avoiding repetition are good practices, for SQL queries they are plain bad. The compilation has to come up with an access path that work for _any_ value of the input parameters and the result is most often sub-optimal.
    
    ## Optimization
    
    Speaking of choosing an optimal data access path, this is the next stage in the lifetime of the request: optimization. In SQL, and in T-SQL, optimization means choosing the best the data access path from all the possible alternatives. Consider that if you have a simple query with join between two tables and each table has an additional index there are already 4 possible ways to access the data and the number of possibilities grows exponentially as the query complexity increases _and_ more alternative access paths are available (basically, more indexes). Add to this that the JOIN can be done using various strategies (nested loop, hash, merge) and you&#8217;ll see why optimization is such an important concept in SQL. SQL Server uses a cost based optimizer, meaning that it will consider all (or at least many) of the possible alternatives, try to make an educated guess about the cost of each alternative, and then choose the one with the lowest cost. Cost is calculated primarily by considering the size of data that would have to be read by each alternative. In order to come up with these costs SQL Server needs to know the size of each table and the distribution of column values, which is are available from the statistics associated with the data. Other factors considered are the CPU consumption and the memory required for each plan alternative. Using formulas tuned over many years of experience all these factors are synthesized into a single cost value for each alternative and then the alternative with the lowest cost is chosen as the query plan to be used.
    
    Exploring all these alternatives can be time consuming and this is why once a query plan is created is also cached for future reuse. Future similar requests can skip the optimization phase if they can find an already compiled and optimized query plan in the SQL Server internal cache. For a lengthier discussion see <a href="http://msdn.microsoft.com/en-us/library/ms181055.aspx" target="_blank">Execution Plan Caching and Reuse</a>.
    
    ## Execution
    
    Once a query plan is chosen by the Optimizer the request can start executing. The query plan gets translated into an actual execution tree. Each node in this tree is an operator. All operators implement an abstract interface with 3 methods: <tt>open()</tt>, <tt>next()</tt>, <tt>close()</tt>. The execution loop consists in calling <tt>open()</tt> on the operator that is at the root of the tree, then calling <tt>next()</tt> repeatedly until it returns false, and finally calling <tt>close()</tt>. The operator at the root of the tree will in turn call the same operation on each of its children operators, and these in turn call the same operations on their child operators and so on. At the leaf the trees there are physical access operators that actually retrieve data from tables and indexes. At intermediate levels there are operators that implement various data operations like filtering data, performing JOINs or sorting the rows. Queries that use parallelism use a special operator called an Exchange operator. The Exchange operator launches multiple threads (tasks => workers) into execution and asks each thread to execute a sub-tree of the query plan. It then aggregates the output from these operators, using a typical <a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem" target="_blank">multiple-producers-one-consumer</a> pattern. An excellent description of this execution model can be found in the <a href="http://paperhub.s3.amazonaws.com/dace52a42c07f7f8348b08dc2b186061.pdf" target="_blank">Volcano-An Extensible and Parallel Query Evaluation System</a>.
    
    This execution model applies not only to queries, but also to data modification (insert, delete, update). There are operators that handle inserting a row, operators that handle deleting a row and operators that handle updating a row. Some requests create trivial plans (eg. a <tt>INSERT INTO ... VALUES ...</tt>) while other creates extremely complex plans, but the execution is identical for all of the and occurs just as I described: the execution tree is iterated calling <tt>next()</tt> until its done.
    
    Certain operators have a special stop-and-go behavior, meaning that they cannot produce any output until they consumed all the input from their own children operators. Examples of such operators is SORT: the very first call to <tt>next()</tt> does not return until all the rows created by the children operators are retrieved and sorted.</p>